require "bool"
require "std:classes"

native ("native", "js") "std:native" {
  add_str(x: str, y: str): str
  mul_str(x: str, y: int): str
  string_length(x: str): int
  eq_string(x: str, y: str): bool
  get_index_str(x: str, i: int): Option<char>
  str_slice(x: str, start: int, end: int): str
}

extend numeric<str> {
  fn (+) (x: str, y: str) => add_str(x, y)
  fn (-) (x: str, y: str) => x
}

extend equality<str> {
  fn (==) (x: str, y: str) => eq_string(x, y)
}

extend show<str> {
  fn show_prec(x: str, prec: int) => switch prec {
    case 0 => x
    case ? => "\"" + x + "\""
  }
}

extend indexable<str, char> {
  fn get_index(self: str, i): Option<char> => get_index_str(self, i)
}

// Inserting a `sep`arator between each element of the list
// and concatenating the result into a single string.
pub fn join_str(c: [str], sep: str) =>
  switch c {
    case [] => ""
    case [x] => x
    case [x, ..xs] => x + sep + xs.join_str(sep)
  }

pub fn unlines(lines: [str]): str => lines.join_str("\n").show()

pub fn str_to_list(string: str): [str] {
    mut result: [str] = []
    mut i = 0

    while *i < string_length(string) {
        _i = *i
        chr = string[_i]
        result += switch chr {
            case None => []
            case Some(chr) => [char_to_string(chr)]
        }
        i += 1
    }
    return *result
}

pub fn str_split(string: str, delimiter: str): [str] {
    delimiter_length = string_length(delimiter)
    string_len = string_length(string)
    mut result: [str] = []
    mut word = ""
    mut i = 0

    while *i < string_len {
        if str_slice(string, *i, *i + delimiter_length) == delimiter {
            if *word == "" {}
            else {
                result += [*word]
                word = ""
            }
            i += delimiter_length
        } else {
            _i = *i
            chr = string[_i]
            word += switch chr {
                case None => ""
                case Some(chr) => char_to_string(chr)
            }
            i += 1
        }
    }

    if *word == "" {}
    else {
        result += [*word]
    }

    return *result
}

// clearing all spaces in a string
pub fn str_strip(string: str): str {
    mut result: str = join_str(str_split(string, "\t"), "")
    result = join_str(str_split(*result, "\n"), "")
    result = join_str(str_split(*result, " "), "")
    return *result
}