require "std:classes"
require "option"
require "tuple"

type Map<K, V> = list<(K, V)>

fn empty<K, V>(): Map<K, V> => []

fn insert<K extends equality, V>(m: Map<K, V>, k: K, v: V): Map<K, V> => 
  switch m {
    case [] => [(k, v)]
    case [(k1, v1), ..m1] => 
      if k == k1 then
        [(k, v)] + m1
      else
        [(k1, v1)] + insert(m1, k, v)
  }

fn lookup<K extends equality, V>(m: Map<K, V>, k: K): Option<V> =>
  switch m {
    case [] => None
    case [(k1, v1), ..m1] =>
      if k == k1 then
        Some(v1)
      else
        lookup(m1, k)
  }

fn remove<K extends equality, V>(m: Map<K, V>, k: K): Map<K, V> =>
  switch m {
    case [] => []
    case [(k1, v1), ..m1] =>
      if k == k1 then
        m1
      else
        [(k1, v1)] + remove(m1, k)
  }

fn invert<K, V>(m: Map<K, V>): Map<V, K> =>
  m.foldl(fn (acc, e) {
    case (k, v) = e
    return insert(acc, v, k)
  }, empty())