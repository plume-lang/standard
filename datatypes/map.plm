require "std:classes"
require "option"
require "tuple"

type Map<K, V> = list<(K, V)>

fn empty<K, V>(): Map<K, V> => []

fn show_map_helper<K extends show, V extends show>(m: Map<K, V>, prec: int): str =>
  switch m {
    case [] => ""
    case [(k, v)] => k.show_prec(prec + 1) + ": " + v.show_prec(prec + 1)
    case [(k, v), ..m1] => k.show_prec(prec + 1) + ": " + v.show_prec(prec + 1) + ", " + show_map_helper(m1, prec)
  }

extend<K extends show, V extends show> show<Map<K, V>> (priority 5) {
  fn show_prec(m: Map<K, V>, prec: int): str =>
    "{ " + show_map_helper(m, prec) + " }"
}

fn insert<K extends equality, V extends equality>(m: Map<K, V>, k: K, v: V): Map<K, V> => 
  switch m {
    case [] => [(k, v)]
    case [(k1, v1), ..m1] => 
      if k == k1 then
        [(k, v)] + m1
      else
        [(k1, v1)] + insert(m1, k, v)
  }

fn lookup<K extends equality, V>(m: Map<K, V>, k: K): Option<V> =>
  switch m {
    case [] => None
    case [(k1, v1), ..m1] =>
      if k == k1 then
        Some(v1)
      else
        lookup(m1, k)
  }

fn remove<K extends equality, V>(m: Map<K, V>, k: K): Map<K, V> =>
  switch m {
    case [] => []
    case [(k1, v1), ..m1] =>
      if k == k1 then
        m1
      else
        [(k1, v1)] + remove(m1, k)
  }
